package 欢乐颂._09基础经典算法;

import java.util.LinkedList;

import org.junit.Test;

/**
 * 题目描述:得到滑动过程窗口中的最大值
 * 	有一个整形数组arr和一个大小为w的窗口从数组中最左面滑到最右面,每次窗口向右面滑动一个位置
 * 	例如: 数组为[4,3,5,4,3,3,6,7] 的窗口大小为3时:
 * 
 * 	    [4 3 5] 4 3 3 6 7	窗口中的最大值为5
 * 		4 [3 5 4] 3 3 6 7	窗口中的最大值为5
 * 		4 3 [5 4 3] 3 6 7	窗口中的最大值为5
 * 		4 3 5 [4 3 3] 6 7	窗口中的最大值为4
 * 		4 3 5 4 [3 3 6] 7	窗口中的最大值为6
 * 		4 3 5 4 3 [3 6 7]	窗口中的最大值为7
 * 
 * 如果数组的长度为n,窗口的大小为w,则一共产生n-w+1个窗口的最大值
 * 
 * 请实现一个函数:
 * 		输入:整形数组arr,窗口大小为w
 * 		输出:一个长度为n-w+1的数组res,res[i]表示每种窗口状态下的最大值
 * 
 * 	以上式子为例返回结果为 [5,5,5,4,6,7]
 * 
 * 思路:首先讲一下窗口的概念,窗口就类似一个队列,一个口负责加元素,另一个口负责减元素(一个双端队列,从小到大)
 *   因此此题可以借助双端队列结构来解决:此题为了方便理解,在队列中放置的是双列元素:value是元素的值,key是元素对应在数组中的下标
 * 	  队列(头部添加,尾部弹出)中放置的元素是有序的(尾部大,头部小),如何保证呢,请看操作:
 * 	  1.窗口添加元素:当窗口添加元素的时候会从队列的头部添加,如果此时头部的元素大于要添加的元素,则直接添加
 * 		否则将头部删除,然后再尝试添加(直到没有元素或找到比自己大的元素)
 * 		(***之所以可以直接将小于等于的值删掉是因为,此题求最大值,所以此窗口的后面有比你还大的,而且还比你晚退休,所以抛弃的这些不可能是最大的值)
 * 	  2.窗口删除元素:窗口的尾部每次删除会检查将要删除的元素的下标是否为,队列尾部元素的key,如果是就从队列中删除此尾部元素,否则不处理	
 *      (**在队列中的元素要保留下标的目的就是我为了,在窗口缩小时判断,当前的下标是否还在窗口内)
 *  		**每次当前窗口的最大值,就是队列尾部的元素
 *  
 *  暴力解发:
 *  	从第一个元素开始到底n-w个元素,依次遍历,每次取到当前元素为头的w个元素,然后排序选出最大值就是,这个窗口的最大值
 * @author Administrator
 */
public class _07滑动窗口问题 {
	
	@Test
	public void main() {
		int[] arr = {4,3,5,4,3,3,6,7};//数组
		int w = 3; //窗口大小
		int[] maxWin = getMaxWindow(arr,w);
		for (int i = 0; i < maxWin.length; i++) {
			System.out.print(maxWin[i]);
		}
	}
	
	//得到每次窗口移动所划过区域的最大值
	private int[] getMaxWindow(int[] arr, int w) {
		//BaseCase
		if (arr==null||w<=0||w>arr.length) {
			return null;
		}
		//创建一个辅助容器双端列表
		LinkedList<Integer> queue = new LinkedList<Integer>();  //队列中可以只存下标,它的值可以根据arr[]获取到
		//创建返回的结果数组
		int[] res = new int[arr.length-w+1];
		//下标
		int index = 0;			
		
		for (int i = 0; i < arr.length; i++) {
			//队列中添加
			while (!queue.isEmpty()&&arr[queue.getFirst()]<=arr[i]) {
				//如果对列不为空,且对列头部的元素比当前元素小则删除对列头部元素
				queue.pollFirst();
			}
			//否则就将元素从队列的头部添加(此处指的是元素的下标)
			queue.addFirst(i);
			
			//此处i-w为窗口的尾部位置
			if (i-w == queue.getLast()) {
				queue.pollLast();
			}
			if (i+1-w >= 0) {
				res[index++] = arr[queue.getLast()];
			}
		}
		return res;
	}

}
